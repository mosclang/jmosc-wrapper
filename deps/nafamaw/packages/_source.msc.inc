// Generated automatically from src/packages/*.msc. Do not edit.
static const char* dumareModuleSource =
"kulu Dumare {\n"
"  dialen diaaBo(reflectee) {\n"
"    nin mirror = FenDumare\n"
"    nii (reflectee ye Kulu) mirror = KuluDumare\n"
"    nii (reflectee ye Djuru) mirror = DjuruDumare\n"
"\n"
"    segin niin mirror.kura_(reflectee)\n"
"  }\n"
"}\n"
"\n"
"kulu FenDumare ye Dumare {\n"
"  nin _reflectee\n"
"  nin _kuluDumare\n"
"  dunan dialen beeseKaWele(reflectee, methodName)\n"
"\n"
"  dilan kura_(reflectee) {\n"
"    ale._reflectee = reflectee\n"
"  }\n"
"\n"
"  kuluDumare {\n"
"    nii (ale._kuluDumare == gansan) ale._kuluDumare = Dumare.diaaBo(ale._reflectee.suku)\n"
"    segin niin ale._kuluDumare\n"
"  }\n"
"\n"
"  moduleMirror { ale.kuluDumare.moduleMirror }\n"
"\n"
"  diaa { ale._reflectee }\n"
"\n"
"  beeseKaWele(signature) { ale.kuluDumare.hasMethod(signature) }\n"
"}\n"
"\n"
"kulu KuluDumare ye FenDumare {\n"
"  nin _moduleMirror\n"
"  nin _methods\n"
"\n"
"  dunan dialen hasMethod(reflectee, signature)\n"
"  dunan dialen methodNames(reflectee)\n"
"\n"
"  dilan kura_(reflectee) {\n"
"    faa(reflectee)\n"
"    ale._moduleMirror = gansan\n"
"\n"
"    ale._methods = KuluDumare.methodNames(reflectee)\n"
"  }\n"
"\n"
"  moduleMirror { ale._moduleMirror }\n"
"\n"
"  hasMethod(signature) { KuluDumare.hasMethod(ale.diaa, signature) }\n"
"\n"
"  methodNames { ale._methods }\n"
"  methodMirrors { ale._methodMirrors }\n"
"}\n"
"\n"
"# Mirror for class Method\n"
"kulu TiidenDumare ye Dumare {\n"
"  nin _method\n"
"  dunan dialen boundToClass_(method)\n"
"  dunan dialen module_(method)\n"
"  dunan dialen signature_(method)\n"
"\n"
"  dilan kura_(method) {\n"
"    ale._method = method\n"
"  }\n"
"\n"
"  boundToKuluDumare { Dumare.diaaBo(TiidenDumare.boundToClass_(ale._method)) }\n"
"  moduleMirror { KabilaDumare.fromModule_(TiidenDumare.module_(ale._method)) }\n"
"\n"
"  signature { TiidenDumare.signature_(ale._method) }\n"
"}\n"
"\n"
"kulu DjuruDumare ye FenDumare {\n"
"  dunan dialen methodAt_(reflectee, stackTraceIndex)\n"
"  dunan dialen lineAt_(reflectee, stackTraceIndex)\n"
"  dunan dialen stackFramesCount_(reflectee)\n"
"\n"
"  dilan kura_(reflectee) {\n"
"    faa(reflectee)\n"
"  }\n"
"\n"
"  lineAt(stackTraceIndex)   { DjuruDumare.lineAt_(ale.diaa, stackTraceIndex) }\n"
"  methodAt(stackTraceIndex) { DjuruDumare.methodAt_(ale.diaa, stackTraceIndex) }\n"
"  stackFramesCount          { DjuruDumare.stackFramesCount_(ale.diaa) }\n"
"\n"
"  stackTrace {\n"
"    nin reflectee = ale.diaa\n"
"    nin stackFramesCount = DjuruDumare.stackFramesCount_(reflectee)\n"
"    segin niin StackTrace.kura_(reflectee, stackFramesCount)\n"
"  }\n"
"}\n"
"\n"
"#Mirror for module\n"
"kulu KabilaDumare ye Dumare {\n"
"\n"
"  dunan dialen fromName_(name)\n"
"  dunan dialen name_(reflectee)\n"
"\n"
"  dialen fromModule_(module) {\n"
"    segin niin KabilaDumare.kura_(module)\n"
"  }\n"
"\n"
"  dialen fromName(name) {\n"
"    nin module = KabilaDumare.fromName_(name)\n"
"    nii (gansan == module) Djuru.tike(\"Unkown module\")\n"
"\n"
"    segin niin KabilaDumare.fromModule_(module)\n"
"  }\n"
"\n"
"  nin _reflectee\n"
"  dilan kura_(reflectee) {\n"
"    ale._reflectee = reflectee\n"
"  }\n"
"\n"
"  name { KabilaDumare.name_(ale._reflectee) }\n"
"}\n"
"\n"
"kulu StackTrace ye Tugun {\n"
"  nin _fiber\n"
"  nin _stackTrace\n"
"  dilan kura_(fiber, stackFramesCount) {\n"
"    ale._fiber = fiber\n"
"    ale._stackTrace = []\n"
"    seginka (0...stackFramesCount kono i) {\n"
"      ale._stackTrace.aFaraAkan(StackTraceFrame.kura_(fiber, i))\n"
"    }\n"
"  }\n"
"  frames { ale._stackTrace }\n"
"  dialen kura(fiber) {\n"
"    nin stackFramesCount = DjuruDumare.stackFramesCount_(fiber)\n"
"\n"
"    segin niin StackTrace.kura_(fiber, stackFramesCount)\n"
"  }\n"
"\n"
"  iterate(iterator, step) { ale._stackTrace.iterate(iterator, step) }\n"
"  iteratorValue(iterator) { ale._stackTrace.iteratorValue(iterator) }\n"
"\n"
"  sebenma { ale._stackTrace.kunBen(\"\\n\") }\n"
"}\n"
"\n"
"kulu StackTraceFrame {\n"
"  nin _line\n"
"  nin _methodMirror\n"
"  dilan kura_(fiber, stackFramesIndex) {\n"
"    ale._line = DjuruDumare.lineAt_(fiber, stackFramesIndex)\n"
"    ale._methodMirror = TiidenDumare.kura_(DjuruDumare.methodAt_(fiber, stackFramesIndex))\n"
"  }\n"
"\n"
"  line { ale._line }\n"
"  methodMirror { ale._methodMirror }\n"
"\n"
"  sebenma { \"at ${ ale._methodMirror.moduleMirror.name }: ${ ale._methodMirror.signature } line ${ ale._line }\" }\n"
"}\n";

// Generated automatically from src/packages/*.msc. Do not edit.
static const char* jsonModuleSource =
"kabo \"ensure\" nani Ensure\n"
"\n"
"# Mainly based on https://github.com/domeengine/dome/blob/develop/src/modules/json.wren\n"
"# Some code based on https://github.com/brandly/wren-json/blob/master/json.wren\n"
"\n"
"kulu JSONOptions {\n"
"  dialen nil { 0 }\n"
"  dialen escapeSolidus { 1 }\n"
"  dialen abortOnError { 2 }\n"
"  dialen checkCircular { 4 }\n"
"\n"
"  dialen bAkono(options, option) {\n"
"    segin niin ((options & option) != JSONOptions.nil)\n"
"  }\n"
"}\n"
"\n"
"kulu JSONError {\n"
"  nin _line\n"
"  nin _position\n"
"  nin _message\n"
"  nin _found\n"
"\n"
"  line { ale._line }\n"
"  yoro { ale._position }\n"
"  tiikan { ale._message }\n"
"  sorola { ale._found }\n"
"\n"
"  dilan kura(line, pos, message, found) {\n"
"    ale._line = line\n"
"    ale._position = pos\n"
"    ale._message = message\n"
"    ale._found = found\n"
"  }\n"
"\n"
"  dialen empty() {\n"
"    segin niin JSONError.kura(0, 0, \"\", galon)\n"
"  }\n"
"}\n"
"\n"
"# pdjson.h:\n"
"\n"
"# enum json_type {\n"
"#     JSON_ERROR = 1, JSON_DONE,\n"
"#     JSON_OBJECT, JSON_OBJECT_END, JSON_ARRAY, JSON_ARRAY_END,\n"
"#     JSON_STRING, JSON_NUMBER, JSON_TRUE, JSON_FALSE, JSON_NULL\n"
"# };\n"
"\n"
"kulu Token {\n"
"  dialen filiDo { 1 }\n"
"  dialen aBanna { 2 }\n"
"  dialen fenDo { 3 }\n"
"  dialen fenLabanDo { 4 }\n"
"  dialen walanDo { 5 }\n"
"  dialen walanLabanDo { 6 }\n"
"  dialen sebenDo { 7 }\n"
"  dialen diatedenDo { 8 }\n"
"  dialen tienDo { 9 }\n"
"  dialen galonDo { 10 }\n"
"  dialen gansanDo { 11 }\n"
"}\n"
"\n"
"kulu JSONStream {\n"
"  # Ensure the stream is always a string\n"
"\n"
"  streamBegin(value) {\n"
"    Ensure.sebenDo(value, \"value\")\n"
"    ale.streamBegin_(value)\n"
"  }\n"
"  dunan streamBegin_(value)\n"
"  \n"
"  dunan streamEnd()\n"
"  dunan next\n"
"  dunan value\n"
"  dunan errorMessage\n"
"  dunan lineno\n"
"  dunan pos\n"
"\n"
"  nin _result\n"
"  nin _raw\n"
"  nin _error\n"
"  nin _lastEvent\n"
"  nin _options\n"
"\n"
"  diabi { ale._result }\n"
"  fili { ale._error }\n"
"  options { ale._options }\n"
"  raw { ale._raw }\n"
"\n"
"  dilan kura(raw, options) {\n"
"    ale._result = {}\n"
"    ale._error = JSONError.empty()\n"
"    ale._lastEvent = gansan\n"
"    ale._raw = raw\n"
"    ale._options = options\n"
"  }\n"
"\n"
"  damine() {\n"
"    ale.streamBegin(ale._raw)\n"
"    ale._result = ale.process(ale.next)\n"
"  }\n"
"\n"
"  laban() {\n"
"    ale.streamEnd()\n"
"  }\n"
"\n"
"  process(event) {\n"
"    ale._lastEvent = event\n"
"\n"
"    nii (event == Token.filiDo) {\n"
"      ale._error = JSONError.kura(ale.lineno, ale.pos, ale.errorMessage, tien)\n"
"      nii (JSONOptions.bAkono(ale._options, JSONOptions.abortOnError)) {\n"
"        ale.laban()\n"
"        Djuru.tike(\"JSON error - line ${ale.lineno} pos ${ale.pos}: ${ale.errorMessage}\")\n"
"      }\n"
"      segin\n"
"    }\n"
"\n"
"    nii (event == Token.aBanna) {\n"
"      segin\n"
"    }\n"
"\n"
"    nii (event == Token.tienDo || event == Token.galonDo) {\n"
"      segin niin (event == Token.tienDo)\n"
"    }\n"
"\n"
"    nii (event == Token.diatedenDo) {\n"
"      segin niin Diat.kaboSebenna(ale.value)\n"
"    }\n"
"\n"
"    nii (event == Token.sebenDo) {\n"
"      segin niin ale.value\n"
"    }\n"
"\n"
"    nii (event == Token.gansanDo) {\n"
"      segin niin gansan\n"
"    }\n"
"\n"
"    nii (event == Token.walanDo) {\n"
"      nin elements = []\n"
"      foo (tien) {\n"
"        event = ale.next\n"
"        ale._lastEvent = event\n"
"        nii (event == Token.walanLabanDo) {\n"
"          atike\n"
"        }\n"
"        elements.aFaraAkan(ale.process(event))\n"
"      }\n"
"      segin niin elements\n"
"    }\n"
"\n"
"    nii (event == Token.fenDo) {\n"
"      nin elements = {}\n"
"      foo (tien) {\n"
"        event = ale.next\n"
"        ale._lastEvent = event\n"
"        nii (event == Token.fenLabanDo) {\n"
"            atike\n"
"        }\n"
"        elements[ale.value] = ale.process(ale.next)\n"
"      }\n"
"      segin niin elements\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"# Protocol for JSON encodable objects\n"
"# Prefer this protocol instead of `sebenma`\n"
"# Override toJSON in the child\n"
"kulu JSONEncodable {\n"
"  toJSON { ale.sebenma }\n"
"}\n"
"\n"
"kulu JSONEscapeChars {\n"
"  dialen hexchars {[\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]}\n"
"\n"
"  dialen toHex(byte) {\n"
"    nin hex = \"\"\n"
"    foo (byte > 0) {\n"
"      nin c = byte % 16\n"
"      hex = ale.hexchars[c] + hex\n"
"      byte = byte >> 4\n"
"    }\n"
"    segin niin hex\n"
"  }\n"
"  \n"
"  dialen lpad(s, count, with) {\n"
"    nii (s.hakan < count) {\n"
"      s = \"${with * (count-s.hakan)}$s\"\n"
"    }\n"
"    segin niin s\n"
"  }\n"
"\n"
"  dialen escape(text, options) {\n"
"    nin substrings = []\n"
"    nin escapeSolidus = JSONOptions.bAkono(options, JSONOptions.escapeSolidus)\n"
"    seginka (text kono char) {\n"
"      nii (char == \"\\\"\") {\n"
"        substrings.aFaraAkan(\"\\\\\\\"\")\n"
"      } note nii (char == \"\\\\\") {\n"
"        substrings.aFaraAkan(\"\\\\\\\\\")\n"
"      } note nii (char == \"\\b\") {\n"
"        substrings.aFaraAkan(\"\\\\b\")\n"
"      } note nii (char == \"\\f\") {\n"
"        substrings.aFaraAkan(\"\\\\f\")\n"
"      } note nii (char == \"\\n\") {\n"
"        substrings.aFaraAkan(\"\\\\n\")\n"
"      } note nii (char == \"\\r\") {\n"
"        substrings.aFaraAkan(\"\\\\r\")\n"
"      } note nii (char == \"\\t\") {\n"
"        substrings.aFaraAkan(\"\\\\t\")\n"
"      } note nii (char.bytes[0] <= 0x1f) {\n"
"        # Control characters!\n"
"        nin byte = char.bytes[0]\n"
"        nin hex = ale.lpad(ale.toHex(byte), 4, \"0\")\n"
"        substrings.aFaraAkan(\"\\\\u\" + hex)\n"
"      } note nii (escapeSolidus && char == \"/\") {\n"
"        substrings.aFaraAkan(\"\\\\/\")\n"
"      } note {\n"
"        substrings.aFaraAkan(char)\n"
"      }\n"
"    }\n"
"    segin niin substrings.kunBen(\"\")\n"
"  }\n"
"}\n"
"\n"
"kulu JSONEncoder {\n"
"  nin _options\n"
"  nin _circularStack\n"
"  dilan kura(options) {\n"
"    ale._options = options\n"
"    ale._circularStack = nii (JSONOptions.bAkono(options, JSONOptions.checkCircular)) [] note gansan\n"
"  }\n"
"\n"
"  isCircle(value) {\n"
"    nii (ale._circularStack == gansan) {\n"
"      segin niin galon\n"
"    }\n"
"    segin niin ale._circularStack.any { (v) => Baa.sukuKelen(value, v) }\n"
"  }\n"
"\n"
"  push(value) {\n"
"    nii (ale._circularStack != gansan) {\n"
"      ale._circularStack.aFaraAkan(value)\n"
"    }\n"
"  }\n"
"  pop() {\n"
"    nii (ale._circularStack != gansan) {\n"
"      ale._circularStack.removeAt(-1)\n"
"    }\n"
"  }\n"
"\n"
"  encode(value) {\n"
"    nii (ale.isCircle(value)) {\n"
"      Djuru.tike(\"Circular JSON\")\n"
"    }\n"
"\n"
"    nii (value ye Diat || value ye Tienya || value ye Gansan) {\n"
"      segin niin value.sebenma\n"
"    }\n"
"\n"
"    nii (value ye Seben) {\n"
"      segin niin \"\\\"\" + JSONEscapeChars.escape(value, ale._options) + \"\\\"\"\n"
"    }\n"
"\n"
"    nii (value ye Walan) {\n"
"      ale.push(value)\n"
"      nin substrings = []\n"
"      seginka (value kono item) {\n"
"        substrings.aFaraAkan(ale.encode(item))\n"
"      }\n"
"      ale.pop()\n"
"      segin niin \"[\" + substrings.kunBen(\",\") + \"]\"\n"
"    }\n"
"\n"
"    nii (value ye Wala) {\n"
"      ale.push(value)\n"
"      nin substrings = []\n"
"      seginka (value.keys kono key) {\n"
"        nin keyValue = ale.encode(value[key])\n"
"        nin encodedKey = ale.encode(key)\n"
"        substrings.aFaraAkan(\"${encodedKey}:${keyValue}\")\n"
"      }\n"
"      ale.pop()\n"
"      segin niin \"{\" + substrings.kunBen(\",\") + \"}\"\n"
"    }\n"
"\n"
"    # Check nii the object implements toJSON\n"
"    nii (value ye JSONEncodable) {\n"
"      segin niin value.toJSON\n"
"    }\n"
"\n"
"    # Default behaviour is to invoke the `sebenma` method\n"
"    segin niin value.sebenma\n"
"  }\n"
"}\n"
"\n"
"kulu JSON {\n"
"\n"
"  dialen encode(value, options) { JSONEncoder.kura(options).encode(value) }\n"
"\n"
"  dialen encode(value) {\n"
"    segin niin JSON.encode(value, JSONOptions.abortOnError)\n"
"  }\n"
"\n"
"  dialen stringify(value) {\n"
"    segin niin JSON.encode(value)\n"
"  }\n"
"\n"
"  dialen decode(value, options) {\n"
"    nin stream = JSONStream.kura(value, options)\n"
"    stream.damine()\n"
"\n"
"    nin result = stream.diabi\n"
"    nii (stream.fili.sorola) {\n"
"      result = stream.fili\n"
"    }\n"
"\n"
"    stream.laban()\n"
"    segin niin result\n"
"  }\n"
"\n"
"  dialen decode(value) {\n"
"    segin niin JSON.decode(value, JSONOptions.abortOnError)\n"
"  }\n"
"\n"
"  dialen parse(value) {\n"
"    segin niin JSON.decode(value)\n"
"  }\n"
"}\n";

// Generated automatically from src/packages/*.msc. Do not edit.
static const char* networkModuleSource =
"kulu Http {\n"
"\n"
"}\n"
"\n"
"kulu Websocket {\n"
"\n"
"}\n";

// Generated automatically from src/packages/*.msc. Do not edit.
static const char* nafamawModuleSource =
"##package=nafamaw\n"
"kabo \"ensure\" nani Ensure\n"
"\n"
"kulu Sebenw {\n"
"    dialen globMatch(str) {\n"
"        segin niin Sebenw.globMatch_(str)\n"
"    }\n"
"    dialen toUpercase(str) {\n"
"        Ensure.sebenDo(str, \"str\")\n"
"        segin niin Sebenw.up_(str)\n"
"    }\n"
"\n"
"    dialen toLowercase(str) {\n"
"            Ensure.sebenDo(str, \"str\")\n"
"            segin niin Sebenw.down_(str)\n"
"    }\n"
"\n"
"\n"
"    dialen capitalize(s) {\n"
"            Ensure.sebenDo(s, \"s\")\n"
"            nii (s.lakalon) segin niin \"\"\n"
"            nii (s.hakan == 1) segin niin Sebenw.up_(s)\n"
"            segin niin Sebenw.up_(s[0]) + s[1..-1]\n"
"        }\n"
"\n"
"        dialen titlecase(s) {\n"
"            Ensure.sebenDo(s, \"s\")\n"
"            segin niin s.faraFara(\" \").yelema {(w) => Sebenw.capitalize(Sebenw.down_(w)) }.kunBen(\" \")\n"
"        }\n"
"\n"
" #* ************************************************************************\n"
"     * Adapting the Tcl `string match` command\n"
"     *\n"
"     * Special characters that can appear in a pattern:\n"
"        *\n"
"            Matches any sequence of characters in string, including a null\n"
"            string.\n"
"\n"
"        ?\n"
"            Matches any single character in string.\n"
"\n"
"        [chars]\n"
"            Matches any character in the set given by chars. If a sequence\n"
"            of the form x-y appears in chars, then any character between x\n"
"            and y, inclusive, will match. Ranges can be forward ([a-z]) or\n"
"            backward ([z-a]).\n"
"\n"
"            In somewhat odd behaviour, patterns ending with unclosed\n"
"            bracket expressions will match successfully:\n"
"                Strings.globMatch(\"a\", \"[a]\")   // expect: true\n"
"                Strings.globMatch(\"a\", \"[a\")    // expect: true\n"
"\n"
"            Additionally, \"]\" can appear inside a bracket expression\n"
"            only as the end of a range.\n"
"\n"
"            Empty bracket expressions are always invalid.\n"
"\n"
"        \\\\x\n"
"            Matches the single character x. This provides a way of\n"
"            avoiding the special interpretation of the characters *?[]\\\\ in\n"
"            pattern. In a wren string, the backslash itself must be escaped:\n"
"                Strings.globMatch(\"a*b\", \"a\\\\*b\")   // expect: true\n"
"\n"
"            Use raw strings to reduce the number of backslashes.\n"
"     *\n"
"     *#\n"
"    dialen globMatch(string, pattern) {\n"
"        Ensure.sebenDo(string, \"string\")\n"
"        Ensure.sebenDo(pattern, \"pattern\")\n"
"        segin niin Sebenw.globMatch_(\n"
"            string,\n"
"            string.hakan,\n"
"            pattern,\n"
"            pattern.hakan\n"
"        )\n"
"    }\n"
"\n"
"\n"
"    dunan dialen up_(str)\n"
"\n"
"    dunan dialen down_(str)\n"
"\n"
"    dunan dialen globMatch_(str, strL, pattern, patternL)\n"
"}\n";

